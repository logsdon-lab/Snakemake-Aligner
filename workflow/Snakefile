include: "rules/common.smk"


SAMPLE_ASSEMBLIES, SAMPLE_READS = get_sample_assemblies_and_reads()
SAMPLE_INFO = {sm["name"]: sm for sm in config["samples"]}

if config.get("output_format") == "cram":
    OUTPUT_EXT = "cram"
    OUTPUT_IDX_EXT = "crai"
else:
    OUTPUT_EXT = "bam"
    OUTPUT_IDX_EXT = "csi" if config.get("use_bam_csi", False) else "bai"


def get_asm(wc):
    return (
        os.path.join(config["output_dir"], f"{wc.sm}_merged_dedup_asm.fa")
        if isinstance(SAMPLE_ASSEMBLIES[str(wc.sm)], dict)
        else SAMPLE_ASSEMBLIES[str(wc.sm)]
    )


if ALIGNER not in ALIGNERS:
    raise ValueError(f"Invalid aligner option. ({ALIGNER})")


include: "rules/winnowmap.smk" if ALIGNER == "winnowmap" else "rules/minimap2.smk"


wildcard_constraints:
    sm="|".join(SAMPLE_ASSEMBLIES.keys()),
    id="|".join(i for sm_reads in SAMPLE_READS.values() for i in sm_reads.keys()),


rule merge_asm_files:
    input:
        asm_files=lambda wc: ancient(SAMPLE_ASSEMBLIES[str(wc.sm)].values()),
    output:
        asm=temp(os.path.join(config["output_dir"], "{sm}_merged_dedup_asm.fa")),
        idx=temp(os.path.join(config["output_dir"], "{sm}_merged_dedup_asm.fa.fai")),
    conda:
        f"env/{ALIGNER}.yaml"
    resources:
        mem=8,
    log:
        os.path.join(LOGS_DIR, "merge_{sm}_asm_files.log"),
    shell:
        """
        {{ find {input.asm_files} -type f -size +0 -exec zcat -f {{}} + | \
        seqkit rmdup ;}} > {output.asm} 2> {log}
        samtools faidx {output.asm}
        """


def get_aln_to_asm(wc) -> list[str]:
    sm_reads = SAMPLE_READS[str(wc.sm)]
    samples = [str(wc.sm)] * len(sm_reads)

    alns = set(
        expand(rules.align_reads_to_asm.output, zip, sm=samples, id=sm_reads.keys())
    )
    if not alns:
        raise FileNotFoundError(f"No reads found for sample: {SAMPLE_INFO[str(wc.sm)]}")
    return ancient(alns)


rule merge_read_asm_alignments:
    input:
        get_aln_to_asm,
    output:
        alignment=os.path.join(config["output_dir"], f"{{sm}}.{OUTPUT_EXT}"),
        alignment_idx=os.path.join(
            config["output_dir"], f"{{sm}}.{OUTPUT_EXT}.{OUTPUT_IDX_EXT}"
        ),
    threads: config["threads_aln"]
    resources:
        mem=config["mem_aln"],
        sort_mem="4G",
    conda:
        f"env/{ALIGNER}.yaml"
    shadow:
        "minimal"
    log:
        os.path.join(LOGS_DIR, "merge_{sm}_read_asm_alignments.log"),
    benchmark:
        os.path.join(BMKS_DIR, "merge_{sm}_read_asm_alignments.tsv")
    params:
        output_format=f"-O {OUTPUT_EXT}",
        use_bam_csi="-c" if OUTPUT_IDX_EXT == "csi" else "",
    shell:
        """
        {{ samtools merge -@ {threads} - {input} | \
        samtools sort -m {resources.sort_mem} -@ {threads} {params.output_format} -;}} > {output.alignment} 2> {log}
        samtools index {params.use_bam_csi} {output.alignment} 2>> {log}
        """


rule align:
    input:
        expand(rules.merge_read_asm_alignments.output, sm=SAMPLE_ASSEMBLIES.keys()),
    default_target: True
